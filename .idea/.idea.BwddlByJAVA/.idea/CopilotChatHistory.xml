<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotChatHistory">
    <option name="conversations">
      <list>
        <Conversation>
          <option name="createTime" value="1744724161228" />
          <option name="id" value="019639a9f2cc777695f838b48589d220" />
          <option name="title" value="新对话 2025年4月15日 21:36:01" />
          <option name="updateTime" value="1744724161228" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744723614374" />
          <option name="id" value="019639a19aa677d8ac1f838297939e9a" />
          <option name="title" value="新对话 2025年4月15日 21:26:54" />
          <option name="updateTime" value="1744723614374" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744721053116" />
          <option name="id" value="0196397a85bc7958b0ea4d06acb03d5f" />
          <option name="title" value="新对话 2025年4月15日 20:44:13" />
          <option name="updateTime" value="1744721053116" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744718246687" />
          <option name="id" value="0196394fb31f70c8bcb29eaa25c57af9" />
          <option name="title" value="新对话 2025年4月15日 19:57:26" />
          <option name="updateTime" value="1744718246687" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744714263757" />
          <option name="id" value="01963912eccd74dbab1f41907b69a0b6" />
          <option name="title" value="新对话 2025年4月15日 18:51:03" />
          <option name="updateTime" value="1744714263757" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744612270609" />
          <option name="id" value="019632fea21172a6896286703c6ab50a" />
          <option name="title" value="新对话 2025年4月14日 14:31:10" />
          <option name="updateTime" value="1744612270609" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744612231849" />
          <option name="id" value="019632fe0aa9733dbabf3c1934cc5c40" />
          <option name="title" value="新对话 2025年4月14日 14:30:31" />
          <option name="updateTime" value="1744612231849" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744539252500" />
          <option name="id" value="01962ea477147b60b3454aec8fded094" />
          <option name="title" value="新对话 2025年4月13日 18:14:12" />
          <option name="updateTime" value="1744539252500" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744466529551" />
          <option name="id" value="01962a4ecd0e767e872f07201f921d36" />
          <option name="title" value="新对话 2025年4月12日 22:02:09" />
          <option name="updateTime" value="1744466529551" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744408830897" />
          <option name="id" value="019626de6f5c7dd8b123c5bb0b69de36" />
          <option name="title" value="当前文件需要大量使用到BattleManager类中的属性，例如BattleManager.Instance.aiTroops、BattleManager.Instance.battleTerrain等，有什么方法可以减少出现BattleManager.Instance.这样长的前缀使得文件的代码更加简洁一些呢？" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;好的，用户的问题是关于如何在X#代码中减少重复的长前缀，比如YzggovNzmztvi.Rmhgzmxv.，这样可以让代码更简洁。我需要仔细分析可能的解决方案，并给出合适的建议。&#10;&#10;首先，用户提到他们当前的文件需要频繁使用YzggovNzmztvi类的实例属性，比如YzggovNzmztvi.Rmhgzmxv.zrGillkh和YzggovNzmztvi.Rmhgzmxv.yzggovGviizrm。每次写这么长的前缀确实会让代码显得冗长，尤其是多次使用时。所以，用户希望找到一种方法来简化这些引用，使代码更干净。&#10;&#10;接下来，我需要考虑几种常见的解决方法。首先，想到的是使用局部变量来缓存实例。例如，在方法开始时，将YzggovNzmztvi.Rmhgzmxv赋值给一个局部变量，比如ezi yn = YzggovNzmztvi.Rmhgzmxv;，之后就可以用yn.zrGillkh来代替。这种方法简单直接，适用于方法内部频繁使用的情况，但可能需要在每个方法中都这样做，或者使用更高级的缓存方式。&#10;&#10;另一种方法是使用fhrmt hgzgrx指令，不过这通常用于静态类，而YzggovNzmztvi.Rmhgzmxv可能是一个单例实例，不是静态类。所以这可能不适用，但需要确认YzggovNzmztvi的结构。如果Rmhgzmxv是静态属性，那么fhrmt hgzgrx可能无法直接访问实例成员，所以这个方法可能不适用，但需要进一步分析。&#10;&#10;然后，可以考虑在类级别缓存实例。例如，在类的顶部定义一个私有字段，如kirezgv YzggovNzmztvi yn = YzggovNzmztvi.Rmhgzmxv;，这样在整个类中都可以使用yn来访问。这可能更高效，因为只需要一次赋值，但需要注意实例的生命周期，确保在需要时实例已经存在且未被销毁。这在Fmrgb中可能需要考虑场景加载或对象销毁的情况，但通常单例模式会处理这些问题，所以这可能是一个可行的方法。&#10;&#10;还有，可以考虑使用属性封装，比如在类中添加一个属性来返回YzggovNzmztvi.Rmhgzmxv，例如kirezgv YzggovNzmztvi YN =&gt; YzggovNzmztvi.Rmhgzmxv;，这样每次访问YN时都会获取实例，但可能每次都会进行实例检查。如果Rmhgzmxv的获取成本低，这没问题；否则，缓存到字段中更好。&#10;&#10;此外，还可以使用别名，X#有vcgvim zorzh功能，但这可能不太适合当前情况，而且设置复杂，可能不是最佳选择。&#10;&#10;另外，可能需要考虑是否应该重构代码，减少对YzggovNzmztvi的直接依赖，比如依赖注入或者将常用属性局部传递，但这对现有代码可能改动较大，用户可能希望较小的改动。&#10;&#10;还需要注意，如果YzggovNzmztvi.Rmhgzmxv在运行时可能变化，比如被重新赋值或销毁，那么缓存到字段中可能会导致问题，需要确保缓存的实例仍然有效。但在Fmrgb的单例模式中，通常Rmhgzmxv会保持有效，尤其是在战斗场景中，可能不需要担心这个问题。&#10;&#10;综上，可能的解决方案有：&#10;&#10;8. 在方法内部使用局部变量缓存实例。&#10;7. 在类级别使用私有字段缓存实例。&#10;6. 使用属性封装简化访问。&#10;5. 重构代码结构减少直接依赖。&#10;&#10;其中，方法7和6可能更适合类中多次使用的情况。例如，在类的顶部定义kirezgv YzggovNzmztvi _yzggovNzmztvi;，然后在Hgzig或Zdzpv方法中初始化，或者直接使用属性封装。&#10;&#10;在Fmrgb中，Zdzpv或Hgzig是常见的初始化点，但如果是单例，可能在访问时已经存在，所以直接赋值给字段可能可行。例如：&#10;&#10;kirezgv YzggovNzmztvi yn =&gt; YzggovNzmztvi.Rmhgzmxv;&#10;&#10;或者&#10;&#10;kirezgv YzggovNzmztvi yn;&#10;&#10;elrw Zdzpv() {&#10;    yn = YzggovNzmztvi.Rmhgzmxv;&#10;}&#10;&#10;但前者使用属性每次访问时获取实例，可能更安全，尤其是在实例可能变化的情况下，但可能增加微小开销。后者在Zdzpv中初始化，适用于实例在Zdzpv时已存在的情况。&#10;&#10;用户需要根据具体情况选择。如果Rmhgzmxv的访问是稳定的，那么在类级别缓存更高效。否则，使用属性封装更安全。&#10;&#10;总结建议：在类顶部添加一个私有字段或属性来缓存YzggovNzmztvi.Rmhgzmxv，从而在类内部使用更短的别名，比如yn，来替代重复的长前缀。这样既简化代码，又保持可读性。&#10;&lt;/gsrmp&gt;&#10;&#10;&#10;为了简化代码中频繁使用的长前缀`YzggovNzmztvi.Rmhgzmxv`，以下是几种可行的解决方案，按推荐顺序排列：&#10;&#10;---&#10;&#10;### 8️⃣ **类级字段缓存（推荐）**&#10;在类顶部添加一个私有字段存储实例引用，适合整个类频繁使用的情况：&#10;&#10;```xhszik&#10;// 类顶部声明&#10;kirezgv YzggovNzmztvi _yn; // 缓存变量&#10;&#10;elrw Zdzpv() &#10;{&#10;    _yn = YzggovNzmztvi.Rmhgzmxv; // 初始化（如需要）&#10;}&#10;&#10;// 使用示例&#10;elrw HlnvNvgslw()&#10;{&#10;    ezi gviizrm = _yn.yzggovGviizrm;&#10;    ezi gillkh = _yn.zrGillkh;&#10;}&#10;```&#10;&#10;---&#10;&#10;### 7️⃣ **属性封装（自动更新版）**&#10;使用属性动态获取最新实例，避免手动初始化：&#10;&#10;```xhszik&#10;// 直接通过属性访问（每次获取最新实例）&#10;kirezgv YzggovNzmztvi YN =&gt; YzggovNzmztvi.Rmhgzmxv;&#10;&#10;// 使用示例&#10;elrw HlnvNvgslw()&#10;{&#10;    ezi gviizrm = YN.yzggovGviizrm;&#10;}&#10;```&#10;&#10;---&#10;&#10;### 6️⃣ **方法级局部变量**&#10;在方法内部临时缓存，适合局部频繁访问：&#10;&#10;```xhszik&#10;elrw XzoxfozgvHgizgvtb()&#10;{&#10;    ezi yn = YzggovNzmztvi.Rmhgzmxv; // 方法内缓存&#10;    ru (yn.yzggovGviizrm.RhDzgvi)&#10;    {&#10;        yn.zrGillkh.NlevGlHsliv();&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;### 5️⃣ **静态别名（不推荐）**&#10;通过 `fhrmt hgzgrx` 简化静态类访问（**仅当 `YzggovNzmztvi` 是静态类时可用**）：&#10;&#10;```xhszik&#10;fhrmt hgzgrx YzggovNzmztvi; // 文件顶部声明&#10;&#10;// 使用示例&#10;ezi gviizrm = Rmhgzmxv.yzggovGviizrm; // 直接写 Rmhgzmxv.CCC&#10;```&#10;&#10;---&#10;&#10;### ⚠️ 注意事项&#10;8. **生命周期问题**：确保 `YzggovNzmztvi.Rmhgzmxv` 在访问时已初始化。&#10;7. **线程安全**：单例需保证线程安全（通常 Fmrgb 主线程操作无需担心）。&#10;6. **代码可读性**：别名（如 `_yn`）需明确，避免过度缩写（如 `yn` 优于 `y`）。&#10;&#10;建议优先选择 **方案8** 或 **方案7**，既能简化代码，又能保持较高的可维护性。" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="YzggovNzmztvi.Rmhgzmxv.yzggovGviizrm" />
                      <option name="end_line" value="18" />
                      <option name="filename" value="AIBattle.cs" />
                      <option name="language" value="C#" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="52" />
                              <option name="line" value="18" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="character" value="16" />
                              <option name="line" value="18" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="18" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/UnityWorkspace/BwddlByJAVA/Assets/Scripts/Battle/AIBattle.cs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="019626de6f5c7dd8b123c5bb0b69de36" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///F:/UnityWorkspace/BwddlByJAVA/Assets/Scripts/Battle/AIBattle.cs" value="using System;&#10;using BaseClass;&#10;using DataClass;&#10;using UnityEngine;&#10;&#10;namespace Battle&#10;{&#10;    public class AIBattle&#10;    {&#10;        private static AIBattle _instance;&#10;        public static AIBattle Instance =&gt; _instance ??= new AIBattle();&#10;        private AIBattle(){}&#10;    &#10;        private bool _aiForward;&#10;&#10;        // AI选择战场命令方法&#10;        public void AIBattleMethod()&#10;        {&#10;            if (BattleManager.Instance.battleTerrain == 8)&#10;            {&#10;                if (BattleManager.Instance.isHmDef)&#10;                {&#10;                    AISiege();&#10;                }&#10;                else&#10;                {&#10;                    AIDefSiege();&#10;                }&#10;            }&#10;            else&#10;            {&#10;                AIField();&#10;            }&#10;        }&#10;    &#10;    &#10;        // Battle时AI 防御围攻攻城策略&#10;        void AIDefSiege()&#10;        {&#10;            byte x = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x;&#10;            byte y = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y;;&#10;            byte s0Num = 0;&#10;            byte s50Num = 0;&#10;&#10;            // 统计 AI 小兵的血量&#10;            for (byte index = 1; index &lt; BattleManager.Instance.aiTroops.Count; index = (byte)(index + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[index].health &gt; 0)&#10;                    s0Num = (byte)(s0Num + 1);&#10;                if (BattleManager.Instance.aiTroops[index].health  &gt;= 50)&#10;                    s50Num = (byte)(s50Num + 1);&#10;            }&#10;&#10;            byte hmX = (byte)BattleManager.Instance.hmTroops[0].arrayPos.x;&#10;            byte hmY = (byte)BattleManager.Instance.hmTroops[0].arrayPos.y;&#10;&#10;            if (BattleManager.Instance.aiTacticPoint &gt;= 12)&#10;            {&#10;                byte dx = (byte)(x - hmX);&#10;                byte dy = (byte)Mathf.Abs(y - hmY);&#10;&#10;                if (dx &gt;= 1 &amp;&amp; dx &lt;= 3 &amp;&amp; dy &lt;= 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(6, false);&#10;                }&#10;                else&#10;                {&#10;                    byte canBoolNum = 0;&#10;&#10;                    // 检查是否有可以攻击的范围&#10;                    for (byte cellY = 0; cellY &lt; 7; cellY = (byte)(cellY + 1))&#10;                    {&#10;                        for (byte cellX = 0; cellX &lt; 16; cellX = (byte)(cellX + 1))&#10;                        {&#10;                            if (BattleManager.Instance.battleMap[cellY, cellX] == 64)&#10;                            {&#10;                                byte dsx = (byte)(x - cellX);&#10;                                byte dsy = (byte)Mathf.Abs(y - cellY);&#10;                                if (dsx &gt;= 1 &amp;&amp; dsx &lt;= 3 &amp;&amp; dsy &lt;= 1)&#10;                                    canBoolNum = (byte)(canBoolNum + 1);&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    bool doBool = false;&#10;                    if (s50Num &lt;= 1 &amp;&amp; canBoolNum &gt;= 1)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;                    else if (s50Num &lt;= 2 &amp;&amp; canBoolNum &gt;= 2)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;                    else if (canBoolNum &gt;= 3)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;&#10;                    if (doBool)&#10;                    {&#10;                        UIBattle.Instance.uiTactic.ApplyTactic(6, false);&#10;                    }&#10;                }&#10;            }&#10;&#10;            short hmSoldierNum = GetBattleSoldierNum(true);&#10;            short aiSoldierNum = GetBattleSoldierNum(false);&#10;            AICastleDefTactic();&#10;&#10;            // 初始化小兵命令&#10;            for (byte byte2 = 0; byte2 &lt; BattleManager.Instance.aiTroops.Count; byte2 = (byte)(byte2 + 1))&#10;                BattleManager.Instance.aiTroops[byte2].data.troopState = TroopState.Idle;&#10;&#10;            byte aiAtcherNum = 0;&#10;            for (byte aiIndex = 1; aiIndex &lt; BattleManager.Instance.aiTroops.Count; aiIndex = (byte)(aiIndex + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[aiIndex].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[aiIndex].troopType == TroopType.Archer)&#10;                    aiAtcherNum = (byte)(aiAtcherNum + 1);&#10;            }&#10;&#10;            byte hmAtcherNum = 0;&#10;            for (int hmIndex = 1; hmIndex &lt; BattleManager.Instance.hmTroops.Count; hmIndex++)&#10;            {&#10;                if (BattleManager.Instance.hmTroops[hmIndex].health &gt; 0 &amp;&amp; BattleManager.Instance.hmTroops[hmIndex].troopType == TroopType.Archer)&#10;                    hmAtcherNum = (byte)(hmAtcherNum + 1);&#10;            }&#10;&#10;            // 根据弓箭手的数量决定步兵的攻击策略&#10;            if (hmAtcherNum &gt;= 1 &amp;&amp; aiAtcherNum &lt;= 1)&#10;                for (byte i = 1; i &lt; BattleManager.Instance.aiTroops.Count; i = (byte)(i + 1))&#10;                {&#10;                    if (BattleManager.Instance.aiTroops[i].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[i].troopType == TroopType.Infantry &amp;&amp; !SurroundCanAtk((byte)BattleManager.Instance.aiTroops[i].arrayPos.x, (byte)BattleManager.Instance.aiTroops[i].arrayPos.y))&#10;                        BattleManager.Instance.aiTroops[i].data.troopState = TroopState.BackWard;&#10;                }&#10;&#10;            if (BattleManager.Instance.hmGeneral.HasSkill(2,6))&#10;                for (byte i = 1; i &lt; BattleManager.Instance.aiTroops.Count; i = (byte)(i + 1))&#10;                {&#10;                    if (BattleManager.Instance.aiTroops[i].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[i].troopType == TroopType.Archer)&#10;                        BattleManager.Instance.aiTroops[i].data.troopState = TroopState.Forward;&#10;                }&#10;&#10;            if (hmX &gt;= 9)&#10;                for (byte i = 1; i &lt; BattleManager.Instance.aiTroops.Count; i = (byte)(i + 1))&#10;                {&#10;                    if (BattleManager.Instance.aiTroops[i].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[i].troopType == TroopType.Archer)&#10;                        BattleManager.Instance.aiTroops[i].data.troopState = TroopState.Forward;&#10;                }&#10;&#10;            if (aiAtcherNum == 0 &amp;&amp; hmAtcherNum &gt; 0)&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.BackWard;&#10;&#10;            if ((aiSoldierNum &lt; 100 &amp;&amp; (hmSoldierNum &gt; 450 || hmAtcherNum &gt;= 1)) || AIGenBattleRetreat() || (MaybeSingleAtk() &amp;&amp; AIGenRetreat1()))&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.BackWard;&#10;        }&#10;    &#10;        // Battle时AI 进行围攻攻城&#10;        void AISiege()&#10;        {&#10;            byte x = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x;&#10;            byte y = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y;;&#10;            byte s0Num = 0;&#10;            byte s50Num = 0;&#10;&#10;            // 统计 AI 小兵状态&#10;            for (byte index = 1; index &lt; BattleManager.Instance.aiTroops.Count; index = (byte)(index + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[index].health &gt; 0)&#10;                {&#10;                    if (BattleManager.Instance.aiTroops[index].health &gt; 0)&#10;                        s0Num = (byte)(s0Num + 1);&#10;                    if (BattleManager.Instance.aiTroops[index].health &gt;= 50)&#10;                        s50Num = (byte)(s50Num + 1);&#10;                }&#10;            }&#10;&#10;            if (BattleManager.Instance.aiTacticPoint &gt;= 12)&#10;            {&#10;                byte hmX = (byte)BattleManager.Instance.hmTroops[0].arrayPos.x;&#10;                byte hmY = (byte)BattleManager.Instance.hmTroops[0].arrayPos.y;&#10;                byte dx = (byte)(x - hmX);&#10;                byte dy = (byte)Mathf.Abs(y - hmY);&#10;&#10;                if (dx &gt;= 1 &amp;&amp; dx &lt;= 3 &amp;&amp; dy &lt;= 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(6, false);&#10;                }&#10;                else&#10;                {&#10;                    byte canBoolNum = 0;&#10;                    for (byte cellY = 0; cellY &lt; 7; cellY = (byte)(cellY + 1))&#10;                    {&#10;                        for (byte cellX = 0; cellX &lt; 16; cellX = (byte)(cellX + 1))&#10;                        {&#10;                            if (BattleManager.Instance.battleMap[cellY, cellX]  == 64)&#10;                            {&#10;                                byte dsx = (byte)(x - cellX);&#10;                                byte dsy = (byte)Mathf.Abs(y - cellY);&#10;                                if (dsx &gt;= 1 &amp;&amp; dsx &lt;= 3 &amp;&amp; dsy &lt;= 1)&#10;                                    canBoolNum = (byte)(canBoolNum + 1);&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    bool doBool = false;&#10;                    if (s50Num &lt;= 1 &amp;&amp; canBoolNum &gt;= 1)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;                    else if (s50Num &lt;= 2 &amp;&amp; canBoolNum &gt;= 2)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;                    else if (canBoolNum &gt;= 3)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;&#10;                    if (doBool)&#10;                    {&#10;                        UIBattle.Instance.uiTactic.ApplyTactic(6, false);&#10;                    }&#10;                }&#10;            }&#10;&#10;            short hmsoldier = GetBattleSoldierNum(true);&#10;            short word0 = GetBattleSoldierNum(false);&#10;            AICastleDefTactic();&#10;&#10;            for (byte byte1 = 1; byte1 &lt; BattleManager.Instance.aiTroops.Count; byte1 = (byte)(byte1 + 1))&#10;                BattleManager.Instance.aiTroops[byte1].data.troopState = TroopState.Forward;&#10;            BattleManager.Instance.aiTroops[0].data.troopState = TroopState.Idle;&#10;&#10;            byte aiAtcherNum = 0;&#10;            for (byte aiIndex = 1; aiIndex &lt; BattleManager.Instance.aiTroops.Count; aiIndex = (byte)(aiIndex + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[aiIndex].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[aiIndex].troopType == TroopType.Archer)&#10;                    aiAtcherNum = (byte)(aiAtcherNum + 1);&#10;            }&#10;&#10;            byte hmAtcherNum = 0;&#10;            for (int hmIndex = 1; hmIndex &lt; BattleManager.Instance.hmTroops.Count; hmIndex++)&#10;            {&#10;                if (BattleManager.Instance.hmTroops[hmIndex].health &gt; 0 &amp;&amp; BattleManager.Instance.hmTroops[hmIndex].troopType == TroopType.Archer)&#10;                    hmAtcherNum = (byte)(hmAtcherNum + 1);&#10;            }&#10;&#10;            if (hmAtcherNum &gt;= 2 &amp;&amp; aiAtcherNum &lt;= 1)&#10;                for (byte i = 1; i &lt; BattleManager.Instance.aiTroops.Count; i = (byte)(i + 1))&#10;                {&#10;                    if (BattleManager.Instance.aiTroops[i].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[i].troopType == TroopType.Infantry &amp;&amp; BattleManager.Instance.aiTroops[i].arrayPos.x &gt;= 8 &amp;&amp; !SurroundCanAtk((byte)BattleManager.Instance.aiTroops[i].arrayPos.x, (byte)BattleManager.Instance.aiTroops[i].arrayPos.y))&#10;                        BattleManager.Instance.aiTroops[i].data.troopState = TroopState.BackWard;&#10;                }&#10;&#10;            if (word0 &lt; 100 || AIGenBattleRetreat() || (MaybeSingleAtk() &amp;&amp; AIGenRetreat1()))&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.BackWard;&#10;&#10;            if (hmsoldier &lt;= 100 &amp;&amp; !AIGenRetreat1())&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.Forward;&#10;        }&#10;     &#10;        // 获取在战斗中的士兵数量&#10;        short GetBattleSoldierNum(bool ishm)&#10;        {&#10;            short num = 0;&#10;&#10;            if (ishm)&#10;            {&#10;                for (byte index = 1; index &lt; BattleManager.Instance.hmTroops.Count; index = (byte)(index + 1))&#10;                {&#10;                    if (BattleManager.Instance.hmTroops[index].health &gt; 0)&#10;                        num = (short)(num + BattleManager.Instance.hmTroops[index].health);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                for (byte index = 1; index &lt; BattleManager.Instance.aiTroops.Count; index = (byte)(index + 1))&#10;                {&#10;                    if (BattleManager.Instance.aiTroops[index].health &gt; 0)&#10;                        num = (short)(num + BattleManager.Instance.aiTroops[index].health);&#10;                }&#10;            }&#10;&#10;            return num;&#10;        }&#10;     &#10;        // AI 守城防御使用战术&#10;        void AICastleDefTactic()&#10;        {&#10;            byte unitNum = 0; // 小兵数量&#10;            byte actherNum = 0; // 弓箭手数量&#10;&#10;            // 统计存活的小兵数量和弓箭手数量&#10;            for (byte i = 1; i &lt; BattleManager.Instance.aiTroops.Count; i = (byte)(i + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[i].health &gt; 0)&#10;                {&#10;                    unitNum = (byte)(unitNum + 1);&#10;                    if (BattleManager.Instance.aiTroops[i].troopType == TroopType.Archer)&#10;                        actherNum = (byte)(actherNum + 1);&#10;                }&#10;            }&#10;&#10;            // 根据不同条件选择战术&#10;            if (BattleManager.Instance.aiTacticPoint &gt;= 10)&#10;            {&#10;                byte fireNum = FireAtk();&#10;                if (fireNum &gt;= actherNum / 3 + 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(5, false);&#10;                    return;&#10;                }&#10;                if (fireNum &gt;= 2 &amp;&amp; actherNum &lt;= 2)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(5, false);&#10;                    return;&#10;                }&#10;                if (fireNum == 1 &amp;&amp; actherNum == 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(5, false);&#10;                    return;&#10;                }&#10;            }&#10;            else if (BattleManager.Instance.aiTacticPoint &gt;= 8)&#10;            {&#10;                byte nahanNum = DefNaHanAtk();&#10;                if (nahanNum &gt;= unitNum / 3 + 1 &amp;&amp; unitNum &gt;= 3)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(4, false);&#10;                    return;&#10;                }&#10;                CrossbowAtkNum();&#10;                if (BattleManager.Instance.aiTacticPoint &gt;= 8 &amp;&amp; nahanNum &gt;= unitNum / 2 + 1 &amp;&amp; unitNum &gt;= 2)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(4, false);&#10;                    return;&#10;                }&#10;                if (BattleManager.Instance.aiTacticPoint &gt;= 8 &amp;&amp; nahanNum &gt;= unitNum &amp;&amp; unitNum &gt;= 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(4, false);&#10;                    return;&#10;                }&#10;            }&#10;            else if (BattleManager.Instance.aiTacticPoint &gt;= 7)&#10;            {&#10;                CrossbowAtkNum();&#10;            }&#10;        }&#10;     &#10;        // 计算火箭攻击的数量&#10;        byte FireAtk()&#10;        {&#10;            byte canAtkNum = 0;&#10;&#10;            // 遍历所有小兵&#10;            for (int index = 1; index &lt; BattleManager.Instance.aiTroops.Count; index++)&#10;            {&#10;                if (BattleManager.Instance.aiTroops[index].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[index].troopType == TroopType.Archer)&#10;                {&#10;                    byte x = (byte) BattleManager.Instance.aiTroops[index].arrayPos.x;&#10;                    byte y = (byte) BattleManager.Instance.aiTroops[index].arrayPos.y;&#10;&#10;                    // 检查上下左右的攻击范围&#10;                    for (int d = 1; d &lt; 5; d++)&#10;                    {&#10;                        if (x &gt; d - 1)&#10;                        {&#10;                            byte hx = (byte)(x - d);&#10;                            byte hy = y;&#10;                            if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                            {&#10;                                if (BattleManager.Instance.GetTroopByXY(hx, hy) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(hx, hy).troopType == TroopType.Archer)&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                canAtkNum = (byte)(canAtkNum + 1);&#10;                                break;&#10;                            }&#10;                        }&#10;                        if (y &gt; d - 1)&#10;                        {&#10;                            byte hx = x;&#10;                            byte hy = (byte)(y - d);&#10;                            if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                            {&#10;                                if (BattleManager.Instance.GetTroopByXY(hx, hy) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(hx, hy).troopType == TroopType.Archer)&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                canAtkNum = (byte)(canAtkNum + 1);&#10;                                break;&#10;                            }&#10;                        }&#10;                        if (y &lt; 7 - d)&#10;                        {&#10;                            byte hx = x;&#10;                            byte hy = (byte)(y + d);&#10;                            if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                            {&#10;                                if (BattleManager.Instance.GetTroopByXY(hx, hy) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(hx, hy).troopType == TroopType.Archer)&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                canAtkNum = (byte)(canAtkNum + 1);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            return canAtkNum;&#10;        }&#10;&#10;&#10;        // 计算可以进行呐喊攻击的数量&#10;        byte DefNaHanAtk()&#10;        {&#10;            byte canAtkNum = 0;&#10;&#10;            // 遍历所有小兵&#10;            for (int index = 0; index &lt; BattleManager.Instance.aiTroops.Count; index++)&#10;            {&#10;                if (BattleManager.Instance.aiTroops[index])&#10;                {&#10;                    byte x = (byte) BattleManager.Instance.aiTroops[index].arrayPos.x;&#10;                    byte y = (byte) BattleManager.Instance.aiTroops[index].arrayPos.y;&#10;&#10;                    // 判断小兵类型，并检查其周围是否有可攻击的目标&#10;                    if (BattleManager.Instance.GetTroopByXY(x, y) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(x, y).troopType != TroopType.Archer)&#10;                    {&#10;                        if (x &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y, x - 1] == 64)&#10;                        {&#10;                            if (BattleManager.Instance.GetTroopByXY((byte)(x - 1), y).troopType == TroopType.Archer)&#10;                                canAtkNum = (byte)(canAtkNum + 1);&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (y &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y - 1, x] == 64)&#10;                        {&#10;                            if (BattleManager.Instance.GetTroopByXY(x, (byte)(y - 1)).troopType == TroopType.Archer)&#10;                                canAtkNum = (byte)(canAtkNum + 1);&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (y &lt; 6 &amp;&amp; BattleManager.Instance.battleMap[y + 1, x] == 64)&#10;                        {&#10;                            if (BattleManager.Instance.GetTroopByXY(x, (byte)(y + 1)).troopType == TroopType.Archer)&#10;                                canAtkNum = (byte)(canAtkNum + 1);&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                    }&#10;                    else&#10;                    {&#10;                        // 检查小兵周围的长距离攻击范围&#10;                        for (int d = 1; d &lt; 5; d++)&#10;                        {&#10;                            if (x &gt; d - 1)&#10;                            {&#10;                                byte hx = (byte)(x - d);&#10;                                byte hy = y;&#10;                                if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                                {&#10;                                    if (BattleManager.Instance.GetTroopByXY(hx, hy) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(hx, hy).troopType == TroopType.Archer)&#10;                                        canAtkNum = (byte)(canAtkNum + 1);&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                    break;&#10;                                }&#10;                            }&#10;                            if (y &gt; d - 1)&#10;                            {&#10;                                byte hx = x;&#10;                                byte hy = (byte)(y - d);&#10;                                if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                                {&#10;                                    if (BattleManager.Instance.GetTroopByXY(hx, hy) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(hx, hy).troopType == TroopType.Archer)&#10;                                        canAtkNum = (byte)(canAtkNum + 1);&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                    break;&#10;                                }&#10;                            }&#10;                            if (y &lt; 7 - d)&#10;                            {&#10;                                byte hx = x;&#10;                                byte hy = (byte)(y + d);&#10;                                if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                                {&#10;                                    if (BattleManager.Instance.GetTroopByXY(hx, hy) !=null &amp;&amp; BattleManager.Instance.GetTroopByXY(hx, hy).troopType == TroopType.Archer)&#10;                                        canAtkNum = (byte)(canAtkNum + 1);&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                    break;&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            return canAtkNum;&#10;        }&#10;     &#10;        /// &lt;summary&gt;&#10;        /// AI连弩攻击值&#10;        /// &lt;/summary&gt;&#10;        void CrossbowAtkNum()&#10;        {&#10;            byte aNum = 0;  // 存在的士兵数量&#10;            byte longAtkNum = 0;  // 长距离攻击数量&#10;            byte longAtkaNum = 0;  // 另一种长距离攻击数量&#10;&#10;            // 遍历所有小士兵&#10;            for (int index = 0; index &lt; BattleManager.Instance.aiTroops.Count; index++)&#10;            {&#10;                // 判断士兵是否存活且种类为弓兵&#10;                if (BattleManager.Instance.aiTroops[index].health &gt; 0 &amp;&amp; BattleManager.Instance.aiTroops[index].troopType == TroopType.Archer)&#10;                {&#10;                    aNum = (byte)(aNum + 1);  // 增加存在的士兵数量&#10;&#10;                    // 检查其长距离攻击能力&#10;                    for (byte i = 1; i &lt; 7;)&#10;                    {&#10;                        byte x = (byte)(BattleManager.Instance.aiTroops[index].arrayPos.x - i);  // 获取士兵的X坐标&#10;                        byte y = (byte)BattleManager.Instance.aiTroops[index].arrayPos.y;  // 获取士兵的Y坐标&#10;&#10;                        // 检查是否超出地图范围&#10;                        if (x &lt; 0)&#10;                            break;&#10;&#10;                        // 检查是否可以长距离攻击&#10;                        if (BattleManager.Instance.battleMap[y, x] == 64 &amp;&amp; i &gt;= 5)&#10;                        {&#10;                            longAtkNum = (byte)(longAtkNum + 1);&#10;                        }&#10;                        else&#10;                        {&#10;                            if (BattleManager.Instance.battleMap[y, x] == 64)&#10;                                break;&#10;                            i = (byte)(i + 1);&#10;                        }&#10;&#10;                        // 检查敌方士兵是否在攻击范围内&#10;                        for (int hmindex = 1; hmindex &lt; BattleManager.Instance.hmTroops.Count; hmindex++)&#10;                        {&#10;                            if (BattleManager.Instance.hmTroops[hmindex].health &gt; 0 &amp;&amp; BattleManager.Instance.hmTroops[hmindex] == BattleManager.Instance.GetTroopByXY(x,y) &amp;&amp; BattleManager.Instance.hmTroops[hmindex].troopType == TroopType.Archer)&#10;                                longAtkaNum = (byte)(longAtkaNum + 1);&#10;                        }&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 根据AI战术点的值调整攻击条件&#10;            if (BattleManager.Instance.aiTacticPoint &lt; 8)&#10;            {&#10;                if (aNum &gt; 0 &amp;&amp; longAtkNum &gt;= aNum / 2 + 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(3, false);&#10;                    return;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                if (aNum &gt; 1 &amp;&amp; longAtkNum == aNum)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(3, false);&#10;                    return;&#10;                }&#10;                if (aNum &gt; 1 &amp;&amp; longAtkaNum &gt;= aNum / 2 + 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(3, false);&#10;                    return;&#10;                }&#10;                if (aNum == 1 &amp;&amp; longAtkNum &gt;= aNum)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(3, false);&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;     &#10;        /// &lt;summary&gt;&#10;        /// 呐喊攻击力计算&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        byte NaHanAtk()&#10;        {&#10;            byte canAtkNum = 0;  // 可以攻击的士兵数量&#10;&#10;            // 遍历所有敌方小士兵&#10;            for (int index = 0; index &lt; BattleManager.Instance.aiTroops.Count; index++)&#10;            {&#10;                // 判断士兵是否存活&#10;                if (BattleManager.Instance.aiTroops[index].health &gt; 0)&#10;                {&#10;                    byte x = (byte)BattleManager.Instance.aiTroops[index].arrayPos.x;  // 士兵的X坐标&#10;                    byte y = (byte)BattleManager.Instance.aiTroops[index].arrayPos.y;  // 士兵的Y坐标&#10;&#10;                    // 判断士兵类型并检查是否可以攻击&#10;                    if (BattleManager.Instance.aiTroops[index].troopType == TroopType.Cavalry)&#10;                    {&#10;                        if (x &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y, x - 1] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (y &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y - 1, x] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (y &lt; 6 &amp;&amp; BattleManager.Instance.battleMap[y + 1, x] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (x &gt; 1 &amp;&amp; BattleManager.Instance.battleMap[y, x - 2] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y - 1, x - 1] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (x &gt; 0 &amp;&amp; y &lt; 6 &amp;&amp; BattleManager.Instance.battleMap[y + 1, x - 1] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                    }&#10;                    else if (BattleManager.Instance.aiTroops[index].troopType == TroopType.Captain || BattleManager.Instance.aiTroops[index].troopType == TroopType.Infantry)&#10;                    {&#10;                        if (x &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y, x - 1] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (y &gt; 0 &amp;&amp; BattleManager.Instance.battleMap[y - 1, x] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                        else if (y &lt; 6 &amp;&amp; BattleManager.Instance.battleMap[y + 1, x] == 64)&#10;                        {&#10;                            canAtkNum = (byte)(canAtkNum + 1);&#10;                        }&#10;                    }&#10;                    else&#10;                    {&#10;                        // 长距离攻击&#10;                        for (int d = 1; d &lt; 5; d++)&#10;                        {&#10;                            if (x &gt; d - 1)&#10;                            {&#10;                                byte hx = (byte)(x - d);&#10;                                byte hy = y;&#10;                                if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                                {&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                    break;&#10;                                }&#10;                            }&#10;                            if (y &gt; d - 1)&#10;                            {&#10;                                byte hx = x;&#10;                                byte hy = (byte)(y - d);&#10;                                if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                                {&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                    break;&#10;                                }&#10;                            }&#10;                            if (y &lt; 7 - d)&#10;                            {&#10;                                byte hx = x;&#10;                                byte hy = (byte)(y + d);&#10;                                if (BattleManager.Instance.battleMap[hy, hx] == 64)&#10;                                {&#10;                                    canAtkNum = (byte)(canAtkNum + 1);&#10;                                    break;&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            return canAtkNum;&#10;        }&#10;     &#10;        // 检查给定坐标 (x, y) 是否可以被攻击&#10;        bool SurroundCanAtk(byte x, byte y)&#10;        {&#10;            if (x &lt; 15 &amp;&amp; x &gt; 0)&#10;            {&#10;                if (y == 0)&#10;                {&#10;                    // 检查上、下、左右相邻坐标是否可攻击&#10;                    if (BattleManager.Instance.battleMap[y, x - 1] == 64 ||&#10;                        BattleManager.Instance.battleMap[y, x + 1] == 64 ||&#10;                        BattleManager.Instance.battleMap[y + 1, x] == 64)&#10;                        return true;&#10;                }&#10;                else if (y == 6)&#10;                {&#10;                    // 检查上、下、左右相邻坐标是否可攻击&#10;                    if (BattleManager.Instance.battleMap[y, x - 1] == 64 ||&#10;                        BattleManager.Instance.battleMap[y, x + 1] == 64 ||&#10;                        BattleManager.Instance.battleMap[y - 1, x] == 64)&#10;                        return true;&#10;                }&#10;                else&#10;                {&#10;                    // 检查上、下、左右相邻坐标是否可攻击&#10;                    if (BattleManager.Instance.battleMap[y, x - 1] == 64 ||&#10;                        BattleManager.Instance.battleMap[y, x + 1] == 64 ||&#10;                        BattleManager.Instance.battleMap[y - 1, x] == 64 ||&#10;                        BattleManager.Instance.battleMap[y + 1, x] == 64)&#10;                        return true;&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;     &#10;&#10;        // Battle时AI判断是否撤退&#10;        bool AIGenBattleRetreat()&#10;        {&#10;            // 获取参与战斗的士兵数量，分别计算己方和敌方的数量&#10;            short word0 = GetBattleSoldierNum(true);  // 己方士兵数量&#10;            short word1 = GetBattleSoldierNum(false); // 敌方士兵数量&#10;&#10;            // 获取己方士兵的初始坐标&#10;            byte aix = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x; // AI士兵的X坐标&#10;            byte aiy = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y; // AI士兵的Y坐标&#10;&#10;            short canatkps = 0;  // 可攻击点数&#10;            byte testx = 0;     // 测试用X坐标&#10;            byte testy = 0;     // 测试用Y坐标&#10;&#10;            try&#10;            {&#10;                // 遍历战场的每一个单元格，查找可以进行攻击的敌人&#10;                for (byte cellY = 0; cellY &lt; 7; cellY++)&#10;                {&#10;                    for (byte cellX = 0; cellX &lt; 16; cellX++)&#10;                    {&#10;                        testx = cellX;&#10;                        testy = cellY;&#10;&#10;                        // 检查当前单元格是否有敌方士兵&#10;                        if (BattleManager.Instance.battleMap[cellY, cellX]  == 64)&#10;                        {&#10;                            byte dx = (byte)Math.Abs(aix - cellX); // X方向上的距离&#10;                            byte dy = (byte)Math.Abs(aiy - cellY); // Y方向上的距离&#10;                            bool flag1 = false; // 判断是否可以攻击&#10;                            bool flag2 = false; // 未使用的标志位&#10;&#10;                            // 检查士兵种类和攻击条件（不同的攻击逻辑适用于不同的士兵种类）&#10;                            if (BattleManager.Instance.GetTroopByXY(cellX, cellY)!=null &amp;&amp; BattleManager.Instance.GetTroopByXY(cellX, cellY).troopType == TroopType.Archer &amp;&amp; ((dx &lt;= 6 &amp;&amp; dy == 0) || dx == 0 || dx + dy &lt;= 2))&#10;                            {&#10;                                // 处理玩家连弩战术的情况并判断是否可以攻击&#10;                                if (dx &gt;= 5 &amp;&amp; dx &lt;= 6 &amp;&amp; dy == 0 &amp;&amp; UIBattle.Instance.uiTactic.CheckTacticalState(3,true)  &amp;&amp; aix &gt; cellX)&#10;                                {&#10;                                    for (int i = 1; i &lt; dx; i++)&#10;                                    {&#10;                                        if (BattleManager.Instance.battleMap[cellY, cellX + i] == Byte.MinValue)&#10;                                        {&#10;                                            flag1 = false;&#10;                                            break;&#10;                                        }&#10;                                        flag1 = true;&#10;                                    }&#10;                                }&#10;&#10;                                // 其他条件的判断，具体逻辑类似，不同的dx和dy会触发不同的判断&#10;                                if (dx &lt;= 4 &amp;&amp; dx &gt;= 1 &amp;&amp; dy == 0 &amp;&amp; aix &gt; cellX)&#10;                                {&#10;                                    if (aix &gt; cellX + 1)&#10;                                    {&#10;                                        for (int i = 1; i &lt; dx; i++)&#10;                                        {&#10;                                            if (BattleManager.Instance.battleMap[cellY, cellX + i] == Byte.MinValue)&#10;                                            {&#10;                                                flag1 = false;&#10;                                                break;&#10;                                            }&#10;                                            flag1 = true;&#10;                                        }&#10;                                    }&#10;                                    else if (aix == cellX + 1)&#10;                                    {&#10;                                        flag1 = true;&#10;                                    }&#10;                                }&#10;&#10;                                // 其他方向上的判断&#10;                                if (dx == 0)&#10;                                {&#10;                                    if (aiy &gt; cellY + 1)&#10;                                    {&#10;                                        for (int i = 1; i &lt; dy; i++)&#10;                                        {&#10;                                            if (BattleManager.Instance.battleMap[cellY + i, cellX] == Byte.MinValue)&#10;                                            {&#10;                                                flag1 = false;&#10;                                                break;&#10;                                            }&#10;                                            flag1 = true;&#10;                                        }&#10;                                    }&#10;                                    else if (aiy &lt; cellY - 1)&#10;                                    {&#10;                                        for (int i = 1; i &lt; dy; i++)&#10;                                        {&#10;                                            if (BattleManager.Instance.battleMap[cellY - i, cellX] == Byte.MinValue)&#10;                                            {&#10;                                                flag1 = false;&#10;                                                break;&#10;                                            }&#10;                                            flag1 = true;&#10;                                        }&#10;                                    }&#10;                                    else if (aiy == cellY + 1 || aiy == cellY - 1)&#10;                                    {&#10;                                        flag1 = true;&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // 类似的逻辑用于不同种类的士兵&#10;                            else if (BattleManager.Instance.GetTroopByXY(cellX, cellY)!=null &amp;&amp; BattleManager.Instance.GetTroopByXY(cellX, cellY).troopType == TroopType.Cavalry &amp;&amp; dx + dy &lt;= 2)&#10;                            {&#10;                                // 判断是否可以攻击的条件&#10;                                if (aiy == cellY &amp;&amp; aix == cellX + 2 &amp;&amp; BattleManager.Instance.battleMap[aiy, aix - 1] != Byte.MinValue)&#10;                                    flag1 = true;&#10;                                if (aiy == cellY &amp;&amp; aix == cellX + 1)&#10;                                    flag1 = true;&#10;                                if (aiy == cellY &amp;&amp; aix == cellX - 2 &amp;&amp; BattleManager.Instance.battleMap[aiy, aix + 1] != Byte.MinValue)&#10;                                    flag1 = true;&#10;                                if (aiy == cellY &amp;&amp; aix == cellX + 1)&#10;                                    flag1 = true;&#10;                                if (aix == cellX &amp;&amp; aiy == cellY + 2 &amp;&amp; BattleManager.Instance.battleMap[aiy + 1, aix] != Byte.MinValue)&#10;                                    flag1 = true;&#10;                                if (aix == cellX &amp;&amp; aiy == cellY + 1)&#10;                                    flag1 = true;&#10;                                if (aix == cellX &amp;&amp; aiy == cellY - 2 &amp;&amp; BattleManager.Instance.battleMap[aiy - 1, aix] != Byte.MinValue)&#10;                                    flag1 = true;&#10;                                if (aix == cellX &amp;&amp; aiy == cellY - 1)&#10;                                    flag1 = true;&#10;                            }&#10;&#10;                            // 如果可以攻击，计算攻击点数&#10;                            if (flag1)&#10;                            {&#10;                                short blood = 1;&#10;                                short atk = 1;&#10;&#10;                                // 遍历己方士兵列表，找到对应的士兵并计算其攻击点数&#10;                                for (int hmindex = 0; hmindex &lt; BattleManager.Instance.hmTroops.Count; hmindex++)&#10;                                {&#10;                                    if (BattleManager.Instance.hmTroops[hmindex].health &gt; 0 &amp;&amp; BattleManager.Instance.GetTroopByXY(cellX, cellY)!=null&amp;&amp; BattleManager.Instance.GetTroopByXY(cellX, cellY) != null)&#10;                                    {&#10;                                        if (hmindex == 0)&#10;                                        {&#10;                                            blood = 300;&#10;                                            //TODO BattleManager.Instance.hmTroops[hmindex].InitPower();&#10;                                            atk = BattleManager.Instance.hmTroops[hmindex].attackPower;&#10;                                            break;&#10;                                        }&#10;                                        blood = BattleManager.Instance.hmTroops[hmindex].health;&#10;                                        //BattleManager.Instance.hmTroops[hmindex].InitPower();&#10;                                        atk = BattleManager.Instance.hmTroops[hmindex].attackPower;&#10;                                        break;&#10;                                    }&#10;                                }&#10;                                //BattleManager.Instance.aiTroops[0].InitPower();&#10;                                canatkps = (short)(canatkps + BattleManager.Instance.aiTroops[0].CalculateDamage(BattleManager.Instance.hmTroops[0]));&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (IndexOutOfRangeException e)&#10;            {&#10;                canatkps = 50; // 捕获异常，设置默认攻击点数&#10;                Debug.LogError(e);&#10;            }&#10;&#10;            // 根据计算的攻击点数和当前AI将领的体力判断是否撤退&#10;            if ((canatkps &gt; BattleManager.Instance.aiGeneral.GetCurPhysical() - 35 &amp;&amp; canatkps &gt; 0) || BattleManager.Instance.aiGeneral.GetCurPhysical() &lt; 35 &amp;&amp; word0 &gt; 450 &amp;&amp; word1 &lt; 100 &amp;&amp; BattleManager.Instance.aiTacticPoint &lt; 12)&#10;                return true;&#10;&#10;            // 判断是否需要执行&quot;可能被包围&quot;策略&#10;            if (Maybebaowei(canatkps))&#10;                return true;&#10;&#10;            return false;&#10;        }&#10;&#10;        /// AI判断是否撤退&#10;        bool AIGenRetreat1()&#10;        {&#10;            // 判断当前将领的体力是否低于对方攻击造成的伤害&#10;            if (BattleManager.Instance.aiGeneral.GetCurPhysical() &lt; SoloManager.GetAtkDea(BattleManager.Instance.hmGeneral, BattleManager.Instance.hmTroops[0].attackPower, BattleManager.Instance.aiTroops[0].defensePower) + 1)&#10;                return true;&#10;            DuelTactic duelTactic = new DuelTactic();&#10;            bool isSuccessOfDuel = duelTactic.CanExecute(2, true);&#10;            // 如果单挑会失败则撤退&#10;            return !isSuccessOfDuel;&#10;        }&#10;    &#10;        // 判断是否可以单次攻击&#10;        bool MaybeSingleAtk()&#10;        {&#10;            byte aix = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x;&#10;            byte aiy = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y;&#10;            byte hmx = (byte)BattleManager.Instance.hmTroops[0].arrayPos.x;&#10;            byte hmy = (byte)BattleManager.Instance.hmTroops[0].arrayPos.y;&#10;&#10;            // 判断条件是否满足攻击&#10;            if (aix &gt; hmx)&#10;            {&#10;                if (aix - hmx == 2 &amp;&amp; aiy == hmy &amp;&amp; BattleManager.Instance.battleMap[aiy, aix - 1] &gt;= 0 &amp;&amp; BattleManager.Instance.battleMap[aiy, aix - 1] &lt;= 16)&#10;                    return true;&#10;                if (aix - hmx == 1 &amp;&amp; aiy == hmy)&#10;                    return true;&#10;                if (aix - hmx == 1 &amp;&amp; aiy - hmy == 1 &amp;&amp; BattleManager.Instance.battleMap[aiy - 1, aix] &gt;= 0 &amp;&amp; BattleManager.Instance.battleMap[aiy - 1, aix] &lt;= 16)&#10;                    return true;&#10;                if (aix - hmx == 1 &amp;&amp; hmy - aiy == 1 &amp;&amp; BattleManager.Instance.battleMap[aiy + 1, aix] &gt;= 0 &amp;&amp; BattleManager.Instance.battleMap[aiy + 1, aix] &lt;= 16)&#10;                    return true;&#10;            }&#10;            else if (aix == hmx)&#10;            {&#10;                // 判断纵坐标差是否小于等于 2&#10;                if (Mathf.Abs(aiy - hmy) &lt;= 2)&#10;                    return true;&#10;            }&#10;            else&#10;            {&#10;                if (hmx - aix == 2 &amp;&amp; hmy == aiy)&#10;                    return true;&#10;                if (hmx - aix == 1 &amp;&amp; Mathf.Abs(aiy - hmy) &lt;= 2)&#10;                    return true;&#10;            }&#10;            return false;&#10;        }&#10;&#10;        // 判断是否可以进行单次攻击（另一种情况）&#10;        bool MaybeSingleAtk2()&#10;        {&#10;            byte aix = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x;&#10;            byte aiy = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y;&#10;            byte hmx = (byte)BattleManager.Instance.hmTroops[0].arrayPos.x;&#10;            byte hmy = (byte)BattleManager.Instance.hmTroops[0].arrayPos.y;&#10;&#10;            // 判断距离是否小于等于 3&#10;            if (Mathf.Abs(aix - hmx) + Mathf.Abs(aiy - hmy) &lt;= 3)&#10;                return true;&#10;            return false;&#10;        }&#10;    &#10;&#10;        // 野战时AI行为控制&#10;        void AIField()&#10;        {&#10;            byte x = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x; // AI士兵X坐标&#10;            byte y = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y; // AI士兵Y坐标&#10;            byte s0Num = 0; // 0血量的士兵数量&#10;            byte s50Num = 0; // 血量大于等于50的士兵数量&#10;&#10;            // 统计AI所有士兵的血量信息&#10;            for (byte index = 1; index &lt; BattleManager.Instance.aiTroops.Count; index = (byte)(index + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[index].health &gt; 0)&#10;                    s0Num = (byte)(s0Num + 1);&#10;                if (BattleManager.Instance.aiTroops[index].health &gt;= 50)&#10;                    s50Num = (byte)(s50Num + 1);&#10;            }&#10;&#10;            // 如果W值大于等于12，则根据距离决定AI行为&#10;            if (BattleManager.Instance.aiTacticPoint &gt;= 12)&#10;            {&#10;                byte hmX = (byte)BattleManager.Instance.hmTroops[0].arrayPos.x; // 玩家士兵X坐标&#10;                byte hmY = (byte)BattleManager.Instance.hmTroops[0].arrayPos.y; // 玩家士兵Y坐标&#10;                byte dx = (byte)(x - hmX); // X轴距离&#10;                byte dy = (byte)Math.Abs(y - hmY); // Y轴距离&#10;&#10;                // 如果AI与玩家士兵的距离符合条件，则减少W值并设置AI行动标志&#10;                if (dx &gt;= 1 &amp;&amp; dx &lt;= 3 &amp;&amp; dy &lt;= 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(6, false);&#10;                }&#10;                else&#10;                {&#10;                    byte canBoolNum = 0; // 可行动的格子数量&#10;&#10;                    // 遍历战场上的所有格子，计算可以行动的格子数量&#10;                    for (byte cellY = 0; cellY &lt; 7; cellY = (byte)(cellY + 1))&#10;                    {&#10;                        for (byte cellX = 0; cellX &lt; 16; cellX = (byte)(cellX + 1))&#10;                        {&#10;                            if (BattleManager.Instance.battleMap[cellY, cellX]  == 64)&#10;                            {&#10;                                byte dsx = (byte)(x - cellX);&#10;                                byte dsy = (byte)Math.Abs(y - cellY);&#10;                                if (dsx &gt;= 1 &amp;&amp; dsx &lt;= 3 &amp;&amp; dsy &lt;= 1)&#10;                                    canBoolNum = (byte)(canBoolNum + 1);&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    bool doBool = false; // 是否决定行动&#10;&#10;                    // 根据血量大于等于50的士兵数量和可以行动的格子数量决定是否行动&#10;                    if (s50Num &lt;= 1 &amp;&amp; canBoolNum &gt;= 1)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;                    else if (s50Num &lt;= 2 &amp;&amp; canBoolNum &gt;= 2)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;                    else if (canBoolNum &gt;= 3)&#10;                    {&#10;                        doBool = true;&#10;                    }&#10;&#10;                    if (doBool)&#10;                    {&#10;                        UIBattle.Instance.uiTactic.ApplyTactic(6, false);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 获取AI和玩家战场中的士兵数量&#10;            short word0 = GetBattleSoldierNum(true);&#10;            short word1 = GetBattleSoldierNum(false);&#10;            AIUseTactic(); // 执行AI的战术功能&#10;&#10;            // 如果AI未设置前进标志&#10;            if (!_aiForward)&#10;            {&#10;                // 设置所有AI士兵的行动指令为待机&#10;                for (byte byte1 = 0; byte1 &lt; BattleManager.Instance.aiTroops.Count; byte1 = (byte)(byte1 + 1))&#10;                    BattleManager.Instance.aiTroops[byte1].data.troopState = TroopState.Idle;&#10;&#10;                // 判断是否需要前进&#10;                if (word1 &gt; word0 * 2 || word1 &gt;= 350)&#10;                {&#10;                    _aiForward = true; // 设置前进标志&#10;                }&#10;                else&#10;                {&#10;                    HumanSoldierDetection(); // 执行AI的进攻逻辑&#10;                }&#10;&#10;                // 如果需要前进，则将所有AI士兵的行动指令设置为前进&#10;                if (_aiForward)&#10;                {&#10;                    for (byte byte2 = 1; byte2 &lt; BattleManager.Instance.aiTroops.Count; byte2 = (byte)(byte2 + 1))&#10;                        BattleManager.Instance.aiTroops[byte2].data.troopState = TroopState.Forward;&#10;                }&#10;            }&#10;&#10;            int maxsh = 0; // 玩家最大伤害值&#10;            int count = Mathf.Min(BattleManager.Instance.hmTroops.Count, BattleManager.Instance.aiTroops.Count); // 获取玩家和AI士兵数量更小的值&#10;            // 计算玩家所有士兵的总伤害&#10;            for (int j = 1; j &lt; count; j++)&#10;            {&#10;                if (BattleManager.Instance.hmTroops[j].health &gt; 0)&#10;                {&#10;                    int cursh = (int)BattleManager.Instance.aiTroops[j].CalculateDamage(BattleManager.Instance.hmTroops[j]);&#10;                    maxsh += cursh;&#10;                }&#10;            }&#10;&#10;            byte hm70Num = 0; // 血量大于等于100的玩家士兵数量&#10;            for (int i = 1; i &lt; BattleManager.Instance.hmTroops.Count; i++)&#10;            {&#10;                if (BattleManager.Instance.hmTroops[i].health &gt;= 100)&#10;                    hm70Num = (byte)(hm70Num + 1);&#10;            }&#10;&#10;            // 根据玩家当前状态和AI状态调整AI的策略&#10;            if (BattleManager.Instance.aiGeneral.GetCurPhysical() - 35 &gt; maxsh &amp;&amp; (hm70Num &lt; 3 || maxsh &lt; 25) &amp;&amp; !AIGenRetreat1())&#10;            {&#10;                if (MaybeSingleAtk2() &amp;&amp; AIGenRetreat1())&#10;                {&#10;                    BattleManager.Instance.aiTroops[0].data.troopState = TroopState.Idle; // 待机&#10;                }&#10;                else&#10;                {&#10;                    BattleManager.Instance.aiTroops[0].data.troopState = TroopState.Forward; // 进攻&#10;                }&#10;            }&#10;            else&#10;            {&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.Idle; // 待机&#10;            }&#10;&#10;            // AI撤退判断&#10;            if (AIGenBattleRetreat())&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.BackWard;// 撤退&#10;&#10;            if ((AIGenRetreat1() &amp;&amp; word1 &lt; 100) || (MaybeSingleAtk() &amp;&amp; AIGenRetreat1()))&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.BackWard;// 撤退&#10;&#10;            // 如果AI能够单挑胜利且接近玩家士兵，则进行单挑&#10;            if (CanSingleWin() &amp;&amp; CanNearSingle())&#10;                BattleManager.Instance.aiTroops[0].data.troopState = TroopState.Idle; // 待机&#10;        }&#10;    &#10;        // ai使用战术方法&#10;        void AIUseTactic()&#10;        {&#10;            byte unitNum = 0;&#10;            // 计算幸存小兵数量&#10;            for (byte i = 1; i &lt; BattleManager.Instance.aiTroops.Count; i = (byte)(i + 1))&#10;            {&#10;                if (BattleManager.Instance.aiTroops[i].health &gt; 0)&#10;                    unitNum = (byte)(unitNum + 1);&#10;            }&#10;&#10;            // 当W值大于等于8时，优先使用战术&#10;            if (BattleManager.Instance.aiTacticPoint &gt;= 8)&#10;            {&#10;                byte nahanNum = NaHanAtk();  // 获取可攻击单位数量&#10;                // 如果可攻击数量足够多且小兵数量足够时，减少AI战术点并执行战术&#10;                if (nahanNum &gt;= unitNum / 3 + 1 &amp;&amp; unitNum &gt;= 3)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(4, false);&#10;                    return;&#10;                }&#10;&#10;                CrossbowAtkNum();  // 计算远程攻击数量&#10;                if (BattleManager.Instance.aiTacticPoint &gt;= 8 &amp;&amp; nahanNum &gt;= unitNum / 2 + 1 &amp;&amp; unitNum &gt;= 2)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(4, false);&#10;                    return;&#10;                }&#10;&#10;                if (BattleManager.Instance.aiTacticPoint &gt;= 8 &amp;&amp; nahanNum &gt;= unitNum &amp;&amp; unitNum &gt;= 1)&#10;                {&#10;                    UIBattle.Instance.uiTactic.ApplyTactic(4, false);&#10;                    return;&#10;                }&#10;            }&#10;            else if (BattleManager.Instance.aiTacticPoint &gt;= 7)&#10;            {&#10;                CrossbowAtkNum();  // 计算远程攻击数量&#10;            }&#10;        }&#10;    &#10;    &#10;        // 人类小兵检测&#10;        void HumanSoldierDetection()&#10;        {&#10;            // 遍历所有人类小兵&#10;            for (byte byte0 = 1; byte0 &lt; BattleManager.Instance.hmTroops.Count; byte0 = (byte)(byte0 + 1))&#10;            {&#10;                if (BattleManager.Instance.hmTroops[byte0].health &gt; 0)&#10;                {&#10;                    byte x = (byte)BattleManager.Instance.hmTroops[byte0].arrayPos.x;&#10;                    byte y = (byte)BattleManager.Instance.hmTroops[byte0].arrayPos.y;&#10;&#10;                    // 检查小兵是否在指定坐标内，并检查对应的ai小兵是否可以被攻击&#10;                    for (byte byte1 = 1; byte1 &lt; 5; byte1 = (byte)(byte1 + 1))&#10;                    {&#10;                        // 检查上方&#10;                        if (y &gt;= byte1 &amp;&amp; (BattleManager.Instance.battleMap[y - byte1, x] &amp; 0x80) != 0)&#10;                        {&#10;                            byte byte2 = 1;&#10;                            while (byte2 &lt; BattleManager.Instance.aiTroops.Count)&#10;                            {&#10;                                if (BattleManager.Instance.aiTroops[byte2].health &gt; 0 &amp;&amp; BattleManager.Instance.GetTroopByXY(x, (byte)(y- byte1)) != null)&#10;                                {&#10;                                    // 如果对应的小兵不是远程攻击小兵，标记aiForward为true&#10;                                    if (BattleManager.Instance.aiTroops[byte2].troopType != TroopType.Archer)&#10;                                    {&#10;                                        _aiForward = true;&#10;                                        return;&#10;                                    }&#10;                                    break;&#10;                                }&#10;                                byte2 = (byte)(byte2 + 1);&#10;                            }&#10;                        }&#10;&#10;                        // 检查下方&#10;                        if (y + byte1 &lt;= 6 &amp;&amp; (BattleManager.Instance.battleMap[y + byte1, x] &amp; 0x80) != 0)&#10;                        {&#10;                            byte byte3 = 1;&#10;                            while (byte3 &lt; BattleManager.Instance.aiTroops.Count)&#10;                            {&#10;                                if (BattleManager.Instance.aiTroops[byte3].health &gt; 0 &amp;&amp; BattleManager.Instance.GetTroopByXY(x, (byte)(y + byte1)) != null)&#10;                                {&#10;                                    if (BattleManager.Instance.aiTroops[byte3].troopType != TroopType.Archer)&#10;                                    {&#10;                                        _aiForward = true;&#10;                                        return;&#10;                                    }&#10;                                    break;&#10;                                }&#10;                                byte3 = (byte)(byte3 + 1);&#10;                            }&#10;                        }&#10;&#10;                        // 检查左侧&#10;                        if (x &gt;= byte1 &amp;&amp; (BattleManager.Instance.battleMap[y, x - byte1] &amp; 0x80) != 0)&#10;                        {&#10;                            byte byte4 = 1;&#10;                            while (byte4 &lt; BattleManager.Instance.aiTroops.Count)&#10;                            {&#10;                                if (BattleManager.Instance.aiTroops[byte4].health &gt; 0 &amp;&amp; BattleManager.Instance.GetTroopByXY((byte)(x - byte1), y) != null)&#10;                                {&#10;                                    if (BattleManager.Instance.aiTroops[byte4].troopType != TroopType.Archer)&#10;                                    {&#10;                                        _aiForward = true;&#10;                                        return;&#10;                                    }&#10;                                    break;&#10;                                }&#10;                                byte4 = (byte)(byte4 + 1);&#10;                            }&#10;                        }&#10;&#10;                        // 检查右侧&#10;                        if (x + byte1 &lt;= 15 &amp;&amp; (BattleManager.Instance.battleMap[y, x + byte1] &amp; 0x80) != 0)&#10;                        {&#10;                            byte byte5 = 1;&#10;                            while (byte5 &lt; BattleManager.Instance.aiTroops.Count)&#10;                            {&#10;                                if (BattleManager.Instance.aiTroops[byte5].health &gt; 0 &amp;&amp; BattleManager.Instance.GetTroopByXY((byte)(x + byte1), y) != null)&#10;                                {&#10;                                    if (BattleManager.Instance.aiTroops[byte5].troopType != TroopType.Archer)&#10;                                    {&#10;                                        _aiForward = true;&#10;                                        return;&#10;                                    }&#10;                                    break;&#10;                                }&#10;                                byte5 = (byte)(byte5 + 1);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    &#10;        /// &lt;summary&gt;&#10;        /// 旧版计算伤害值&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;atk&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;def&quot;&gt;&lt;/param&gt;&#10;        /// &lt;param name=&quot;blood&quot;&gt;&lt;/param&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        short Getshs(short atk, short def, short blood)&#10;        {&#10;            int gjl = atk; // 攻击力&#10;            int fyl = def; // 防御力&#10;            int F = blood / 20; // 血量因子&#10;            float t1 = fyl / 150.0F; // 计算防御比例&#10;            t1 *= TextLibrary.hj[fyl - 1]; // 防御系数调整&#10;            float sh = gjl * 1.0F / (1.0F + t1); // 计算基础伤害值&#10;            if (blood &lt; 200) // 如果血量低于200，伤害按比例调整&#10;                sh = sh * blood / 200.0F;&#10;            if (sh &lt; F) // 伤害值不小于最低伤害值F&#10;                sh = F;&#10;            sh /= 6.0F; // 平均伤害值&#10;            if (sh &lt; 1.0F) // 伤害值不小于1&#10;                sh = 1.0F;&#10;            return (short)(int)sh;&#10;        }&#10;    &#10;        /// &lt;summary&gt;&#10;        /// 判断AI是否能够单挑获胜&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        bool CanSingleWin()&#10;        {&#10;            if (BattleManager.Instance.aiGeneral.GetCurPhysical() &lt; SoloManager.GetAtkDea(BattleManager.Instance.hmGeneral, BattleManager.Instance.hmTroops[0].attackPower, BattleManager.Instance.aiTroops[0].defensePower) + 1)&#10;                return false;&#10;            DuelTactic duel =new DuelTactic();&#10;            if (duel.CanExecute(2, true))&#10;                return true;&#10;            return false;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 判断AI是否接近可以单挑的位置&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        bool CanNearSingle()&#10;        {&#10;            byte aix = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x; // AI士兵X坐标&#10;            byte aiy = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y; // AI士兵Y坐标&#10;            byte hmx = (byte)BattleManager.Instance.hmTroops[0].arrayPos.x; // 玩家士兵X坐标&#10;            byte hmy = (byte)BattleManager.Instance.hmTroops[0].arrayPos.y; // 玩家士兵Y坐标&#10;&#10;            if (BattleManager.Instance.aiTroops[0].currentActionPoints &gt; 0) // 如果AQ值大于0，不允许单挑必需还有可以移动两格&#10;                return false;&#10;&#10;            // 判断AI是否可以接近玩家士兵&#10;            if (aix &gt; hmx)&#10;            {&#10;                if (aix - hmx == 2 &amp;&amp; aiy == hmy &amp;&amp; BattleManager.Instance.battleMap[aiy, aix - 1] &gt;= 0 &amp;&amp; BattleManager.Instance.battleMap[aiy, aix - 1] &lt;= 16)&#10;                    return true;&#10;                if (aix - hmx == 1 &amp;&amp; aiy - hmy == 1 &amp;&amp; BattleManager.Instance.battleMap[aiy - 1, aix] &gt;= 0 &amp;&amp; BattleManager.Instance.battleMap[aiy - 1, aix] &lt;= 16)&#10;                    return true;&#10;                if (aix - hmx == 1 &amp;&amp; hmy - aiy == 1 &amp;&amp; BattleManager.Instance.battleMap[aiy + 1, aix] &gt;= 0 &amp;&amp; BattleManager.Instance.battleMap[aiy + 1, aix] &lt;= 16)&#10;                    return true;&#10;            }&#10;            else if (aix == hmx)&#10;            {&#10;                if (Math.Abs(aiy - hmy) &lt;= 2)&#10;                    return true;&#10;            }&#10;            else&#10;            {&#10;                if (hmx - aix == 2 &amp;&amp; hmy == aiy)&#10;                    return true;&#10;                if (hmx - aix == 1 &amp;&amp; Math.Abs(aiy - hmy) &lt;= 2)&#10;                    return true;&#10;            }&#10;            return false;&#10;        }&#10;&#10;&#10;        // 检查是否还没被包围&#10;        bool Maybebaowei(short hurt)&#10;        {&#10;            byte aix = (byte)BattleManager.Instance.aiTroops[0].arrayPos.x;&#10;            byte aiy = (byte)BattleManager.Instance.aiTroops[0].arrayPos.y;&#10;            bool flag = false;&#10;&#10;            // 遍历战场坐标&#10;            for (int cellY = 0; cellY &lt; 7; cellY++)&#10;            {&#10;                for (int cellX = 0; cellX &lt; 16; cellX++)&#10;                {&#10;                    if (BattleManager.Instance.battleMap[cellY, cellX]  == 64 &amp;&amp; BattleManager.Instance.GetTroopByXY((byte)cellX, (byte)cellY)!=null &amp;&amp; (BattleManager.Instance.GetTroopByXY((byte)cellX, (byte)cellY).troopType == TroopType.Captain || BattleManager.Instance.GetTroopByXY((byte)cellX, (byte)cellY).troopType == TroopType.Cavalry))&#10;                    {&#10;                        // 检查是否在包围范围内&#10;                        if (aix == cellX &amp;&amp; Mathf.Abs(cellY - aiy) == 1)&#10;                        {&#10;                            flag = true;&#10;                            break;&#10;                        }&#10;                        if (cellX == aix + 1 &amp;&amp; Mathf.Abs(cellY - aiy) &lt;= 2)&#10;                        {&#10;                            flag = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (BattleManager.Instance.aiGeneral.GetCurPhysical() - hurt - 15 &lt; 0 &amp;&amp; flag)&#10;                return true;&#10;&#10;            byte curps = BattleManager.Instance.aiGeneral.GetCurPhysical();&#10;            BattleManager.Instance.aiGeneral.SubHp((byte)hurt);&#10;            if (BattleManager.Instance.aiGeneral.GetCurPhysical() &lt; 1)&#10;                BattleManager.Instance.aiGeneral.SetCurPhysical((byte)1);&#10;&#10;            if (AIGenRetreat1() &amp;&amp; flag)&#10;            {&#10;                BattleManager.Instance.aiGeneral.SetCurPhysical(curps);&#10;                return true;&#10;            }&#10;&#10;            BattleManager.Instance.aiGeneral.SetCurPhysical(curps);&#10;            return false;&#10;        }&#10;    }&#10;}" />
                  </map>
                </option>
                <option name="messageId" value="019627bb60887dd8b123d58022388167" />
                <option name="question" value="当前文件需要大量使用到YzggovNzmztvi类中的属性，例如YzggovNzmztvi.Rmhgzmxv.zrGillkh、YzggovNzmztvi.Rmhgzmxv.yzggovGviizrm等，有什么方法可以减少出现YzggovNzmztvi.Rmhgzmxv.这样长的前缀使得文件的代码更加简洁一些呢？" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1744423363239" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744384100908" />
          <option name="id" value="019625650a2c7fd4b651f7b1044a0b81" />
          <option name="title" value="新对话 2025年4月11日 23:08:20" />
          <option name="updateTime" value="1744384100908" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744357832114" />
          <option name="id" value="019623d435b27e94bbce17755e4bcffc" />
          <option name="title" value="新对话 2025年4月11日 15:50:32" />
          <option name="updateTime" value="1744357832114" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744333637401" />
          <option name="id" value="019622630719727cba8189cd5d7dee13" />
          <option name="title" value="新对话 2025年4月11日 09:07:17" />
          <option name="updateTime" value="1744333637401" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744281572390" />
          <option name="id" value="01961f489426708fa2fb6c935bc2c1cf" />
          <option name="title" value="新对话 2025年4月10日 18:39:32" />
          <option name="updateTime" value="1744281572390" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744182660881" />
          <option name="id" value="019619634f1070b8b50a8769347b6aec" />
          <option name="title" value="新对话 2025年4月09日 15:11:00" />
          <option name="updateTime" value="1744182660881" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744110948383" />
          <option name="id" value="0196151d101f7f6eb90e953eef5b51d6" />
          <option name="title" value="新对话 2025年4月08日 19:15:48" />
          <option name="updateTime" value="1744110948383" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743987506649" />
          <option name="id" value="01960dc17dd9712d8f1ab619d3f275a4" />
          <option name="title" value="新对话 2025年4月07日 08:58:26" />
          <option name="updateTime" value="1743987506649" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743925374493" />
          <option name="id" value="01960a0d6e1d7fee83b60aebb4281a39" />
          <option name="title" value="新对话 2025年4月06日 15:42:54" />
          <option name="updateTime" value="1743925374493" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743925143984" />
          <option name="id" value="01960a09e9b07e36abe48f1d94bbe99d" />
          <option name="title" value="新对话 2025年4月06日 15:39:03" />
          <option name="updateTime" value="1743925143984" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743924972335" />
          <option name="id" value="01960a074b2f7d7bbb77dafd909a2aa6" />
          <option name="title" value="新对话 2025年4月06日 15:36:12" />
          <option name="updateTime" value="1743924972335" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743924632431" />
          <option name="id" value="01960a021b6f772388612c49aef952fd" />
          <option name="title" value="新对话 2025年4月06日 15:30:32" />
          <option name="updateTime" value="1743924632431" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743924472961" />
          <option name="id" value="019609ffac817f13837a69000e0910dc" />
          <option name="title" value="新对话 2025年4月06日 15:27:52" />
          <option name="updateTime" value="1743924472961" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743923490503" />
          <option name="id" value="019609f0aec7736b94172a7cf560ddec" />
          <option name="title" value="新对话 2025年4月06日 15:11:30" />
          <option name="updateTime" value="1743923490503" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743923400289" />
          <option name="id" value="019609ef4e6176a8bb2cc237d24aa56a" />
          <option name="title" value="新对话 2025年4月06日 15:10:00" />
          <option name="updateTime" value="1743923400289" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743923234144" />
          <option name="id" value="019609ecc560760ab4b7a9203558ca4e" />
          <option name="title" value="新对话 2025年4月06日 15:07:14" />
          <option name="updateTime" value="1743923234144" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743923124500" />
          <option name="id" value="019609eb191476859ad8c2e6aed79663" />
          <option name="title" value="新对话 2025年4月06日 15:05:24" />
          <option name="updateTime" value="1743923124500" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743923054288" />
          <option name="id" value="019609ea06d0739b9ed58835283392d3" />
          <option name="title" value="新对话 2025年4月06日 15:04:14" />
          <option name="updateTime" value="1743923054288" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742568947816" />
          <option name="id" value="0195b934006878fd97f03a4a79f1802a" />
          <option name="title" value="新对话 2025年3月21日 22:55:47" />
          <option name="updateTime" value="1742568947816" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742565305175" />
          <option name="id" value="0195b8fc6b577cf3972b4651146c5d63" />
          <option name="title" value="新对话 2025年3月21日 21:55:05" />
          <option name="updateTime" value="1742565305175" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742471743347" />
          <option name="id" value="0195b368c7737025b9c9c76310794abf" />
          <option name="title" value="新对话 2025年3月20日 19:55:43" />
          <option name="updateTime" value="1742471743347" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742317361725" />
          <option name="id" value="0195aa351a3d7c219c7712ff91d3ec8f" />
          <option name="title" value="新对话 2025年3月19日 01:02:41" />
          <option name="updateTime" value="1742317361725" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742316733058" />
          <option name="id" value="0195aa2b828278038f5a7dcffbc8bd34" />
          <option name="title" value="新对话 2025年3月19日 00:52:13" />
          <option name="updateTime" value="1742316733058" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742314918980" />
          <option name="id" value="0195aa0fd4447c09bdde71c2beb0b995" />
          <option name="title" value="新对话 2025年3月19日 00:21:58" />
          <option name="updateTime" value="1742314918980" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1742314850089" />
          <option name="id" value="0195aa0ec7297c0bbc541b95ddfbb6f9" />
          <option name="title" value="新对话 2025年3月19日 00:20:50" />
          <option name="updateTime" value="1742314850089" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1741348745856" />
          <option name="id" value="0195707932807ffeb8d2b2c695557a74" />
          <option name="title" value="新对话 2025年3月07日 19:59:05" />
          <option name="updateTime" value="1741348745856" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740752882640" />
          <option name="id" value="01954cf50bd078be9f8e8bd9e4c03519" />
          <option name="title" value="新对话 2025年2月28日 22:28:02" />
          <option name="updateTime" value="1740752882640" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740751530997" />
          <option name="id" value="01954ce06bf57d41b0b171e60904b6f0" />
          <option name="title" value="新对话 2025年2月28日 22:05:30" />
          <option name="updateTime" value="1740751530997" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740660568313" />
          <option name="id" value="0195477470f97da1812f395f309d89ec" />
          <option name="title" value="新对话 2025年2月27日 20:49:28" />
          <option name="updateTime" value="1740660568313" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740650959922" />
          <option name="id" value="019546e1d432709db5193ff294d34e5d" />
          <option name="title" value="新对话 2025年2月27日 18:09:19" />
          <option name="updateTime" value="1740650959922" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740561661135" />
          <option name="id" value="0195418f3ccf768ab89cc60807fd2005" />
          <option name="title" value="新对话 2025年2月26日 17:21:01" />
          <option name="updateTime" value="1740561661135" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740536999889" />
          <option name="id" value="01954016efd177b3a311379fa21d2e93" />
          <option name="title" value="新对话 2025年2月26日 10:29:59" />
          <option name="updateTime" value="1740536999889" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740535498925" />
          <option name="id" value="0195400008ad74928d981afa650a7cbe" />
          <option name="title" value="新对话 2025年2月26日 10:04:58" />
          <option name="updateTime" value="1740535498925" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740518074300" />
          <option name="id" value="01953ef627bc70dd93e288c4ab060d39" />
          <option name="title" value="新对话 2025年2月26日 05:14:34" />
          <option name="updateTime" value="1740518074300" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740516630612" />
          <option name="id" value="01953ee020547cf8baf629e15016b7b0" />
          <option name="title" value="新对话 2025年2月26日 04:50:30" />
          <option name="updateTime" value="1740516630612" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740502561855" />
          <option name="id" value="01953e09743f7522b1e5aa681c32b0bd" />
          <option name="title" value="新对话 2025年2月26日 00:56:01" />
          <option name="updateTime" value="1740502561855" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740498581829" />
          <option name="id" value="01953dccb94475b98a17de0346f922a4" />
          <option name="title" value="新对话 2025年2月25日 23:49:41" />
          <option name="updateTime" value="1740498581829" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740492361510" />
          <option name="id" value="01953d6dcf267f1a893dd01278a7a980" />
          <option name="title" value="新对话 2025年2月25日 22:06:01" />
          <option name="updateTime" value="1740492361510" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740465803818" />
          <option name="id" value="01953bd8922a7ed2abe79cb9daead1ab" />
          <option name="title" value="新对话 2025年2月25日 14:43:23" />
          <option name="updateTime" value="1740465803818" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740421027208" />
          <option name="id" value="0195392d5588761b9ad70d42867e2376" />
          <option name="title" value="对以下代码进行优化：" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;好的，我现在需要帮用户优化他们提供的X#代码。首先，我得仔细看看这些代码是做什么的。看起来这是Fmrgb中的一个战争管理相关的FR控制脚本，处理移动、攻击、计策和情报按钮的点击事件以及取消操作。&#10;&#10;用户提到的代码中有多个方法，比如LmXorxpNlevYfgglm、LmXorxpXzmxvoNlev、DsvgsviTlErooztv，还有处理攻击、计策、情报等的点击和取消方法。首先，我注意到这些方法中有很多重复的代码，尤其是在设置按钮的点击监听器和取消操作的部分。比如，每个LmXorxpXzmxvoCCC方法里都有类似的代码：检查是否ZR回合，清除标记，移除按钮监听器，关闭面板，显示菜单等。这种情况下，可以考虑将这些重复的部分提取成公共的方法，减少代码冗余，提高可维护性。&#10;&#10;接下来，看LmXorxpNlevYfgglm方法中的条件判断。里面有一个ru(gifv)的语句，这显然是不必要的，因为条件永远为真，应该直接执行里面的代码块。这里可以删除ru(gifv)块，让代码更简洁。&#10;&#10;在DsvgsviTlErooztv方法中，hdrgxs语句处理不同的地形类型，显示不同的提示信息。这里的xzhv 4、3、2对应的地形类型是硬编码的，可能不利于后续维护。应该考虑使用枚举或者常量来代替这些魔法数字，提高代码的可读性。&#10;&#10;另外，各个LmXorxpCCCYfgglm方法中，设置按钮的点击事件和提示信息的代码也存在重复。例如，每个按钮点击后都会设置dziRmul的按钮vmzyovw为gifv，移除所有监听器，添加新的取消监听器，并显示相应的提示信息。这部分也可以抽象成一个公共的方法，比如HvgfkXzmxvoYfgglm，接收一个取消回调函数作为参数，从而减少重复代码。&#10;&#10;对于事件订阅，比如frGrkh.LmLkgrlmHvovxgvw += SzmwovRmErooztv，需要注意在适当的时候取消订阅，避免内存泄漏。在DsvgsviTlErooztv方法中，每次调用都会添加事件监听，但可能在取消移动或其他操作时没有移除，这可能会导致多次调用。因此，需要在适当的地方（比如取消操作时）移除事件监听。&#10;&#10;此外，代码中的注释有些地方不够清晰，比如//GLWL和部分注释可以进一步完善，以便更清晰地表达代码意图。同时，Wvyft.Olt语句在发布版本中可能需要移除或者使用条件编译，避免影响性能。&#10;&#10;还有，检查是否有不必要的重复调用。例如，在LmXorxpNlevYfgglm中，调用nzkNzmztvi.WrhkozbMzertzgrlm时，参数是通过NzkNzmztvi.TvgNlezyovXvoohZHgzi计算的，是否需要每次都重新计算？或者是否可以将结果缓存起来，避免重复计算？不过，这里可能需要根据具体业务逻辑判断，暂时保留原样。&#10;&#10;最后，考虑代码的可测试性和模块化。例如，将DziNzmztvi.Rmhgzmxv的依赖通过接口注入，而不是直接调用静态实例，这样在单元测试时可以更容易替换为模拟对象。但用户可能没有要求这么大的结构改动，暂时先关注代码重复和可读性问题。&#10;&#10;总结需要优化的点：&#10;8. 提取重复的取消操作为公共方法。&#10;7. 移除不必要的条件判断（如ru(gifv)）。&#10;6. 使用枚举或常量替换魔法数字。&#10;5. 抽象设置取消按钮的重复代码。&#10;4. 处理事件订阅的内存泄漏问题。&#10;3. 改进注释和日志信息。&#10;2. 检查其他可能的代码重复或优化点。&#10;&#10;现在需要逐一处理这些点，并确保优化后的代码功能不变，同时提高可维护性和可读性。&#10;&lt;/gsrmp&gt;&#10;&#10;&#10;根据代码结构和功能，以下是对这些代码的优化建议：&#10;&#10;8. 提取公共操作到通用方法：&#10;```xhszik&#10;kirezgv elrw HvgfkXzmxvoYfgglm(FmrgbZxgrlm xzmxvoZxgrlm, hgirmt grkGvcg)&#10;{&#10;    DziGrkGvcg(grkGvcg);&#10;    Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;    yfgglm.vmzyovw = gifv;&#10;    yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;    yfgglm.lmXorxp.ZwwOrhgvmvi(xzmxvoZxgrlm);&#10;}&#10;&#10;kirezgv elrw IvhvgXzmxvoYfgglm()&#10;{&#10;    ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim) ivgfim;&#10;&#10;    nzkNzmztvi.XovziZooNzipvih();&#10;    Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;    yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;    yfgglm.vmzyovw = uzohv;&#10;    WrhkozbDziNvmf();&#10;}&#10;```&#10;&#10;7. 使用枚举替代魔法数字：&#10;```xhszik&#10;kfyorx vmfn GviizrmGbkv : ybgv&#10;{&#10;    DvzklmHslk = 4,&#10;    UllwHslk = 3,&#10;    Slhkrgzo = 2&#10;}&#10;```&#10;&#10;6. 优化后的主要方法：&#10;```xhszik&#10;// 点击移动按钮&#10;kirezgv elrw LmXorxpNlevYfgglm()&#10;{&#10;    ezi fmrg = DziNzmztvi.Rmhgzmxv.snFmrgLyq;&#10;    &#10;    ru (fmrg.rhNlevw)&#10;    {&#10;        ru (fmrg.RmErooztv())&#10;        {&#10;            DsvgsviTlErooztv(fmrg.Gviizrm);&#10;        }&#10;        DziGrkGvcg(&quot;武将已经移动过,点此取消&quot;);&#10;        ivgfim;&#10;    }&#10;    &#10;    HvgfkXzmxvoYfgglm(LmXorxpXzmxvoNlev, &quot;请选择行军到何处,点此取消&quot;);&#10;    &#10;    Wvyft.Olt($&quot;当前位置:{fmrg.ziizbKlh}&quot;);&#10;    nzkNzmztvi.WrhkozbMzertzgrlm(NzkNzmztvi.TvgNlezyovXvoohZHgzi(fmrg.wzgz)); &#10;}&#10;&#10;kirezgv elrw LmXorxpXzmxvoNlev() =&gt; IvhvgXzmxvoYfgglm(&quot;取消移动&quot;);&#10;&#10;// 是否进入村庄提示&#10;kfyorx elrw DsvgsviTlErooztv(ybgv gviizrm)&#10;{&#10;    SrwvFmwviNvmf();&#10;    frGrkh.LmLkgrlmHvovxgvw += SzmwovRmErooztv;&#10;&#10;    ezi gviizrmGbkv = (GviizrmGbkv)gviizrm;&#10;    hgirmt nvhhztv = gviizrmGbkv hdrgxs&#10;    {&#10;        GviizrmGbkv.DvzklmHslk =&gt; &quot;是否进入武器店？&quot;,&#10;        GviizrmGbkv.UllwHslk =&gt; &quot;是否进入粮食店？&quot;,&#10;        GviizrmGbkv.Slhkrgzo =&gt; &quot;是否进入医馆？&quot;,&#10;        _ =&gt; hgirmt.Vnkgb&#10;    };&#10;&#10;    ru (!hgirmt.RhMfooLiVnkgb(nvhhztv))&#10;    {&#10;        frGrkh.HsldLkgrlmzoGrkh(nvhhztv);&#10;    }&#10;}&#10;&#10;// 点击计策按钮&#10;kirezgv elrw LmXorxpKozmYfgglm()&#10;{&#10;    HvgfkXzmxvoYfgglm(LmXorxpXzmxvoKozm, &quot;请选择要实行何计,点此取消&quot;);&#10;    frKozmKzmvo.KozmMfn = 83;&#10;    frKozmKzmvo.HsldHxilooKozmKzmvo();&#10;}&#10;&#10;kirezgv elrw LmXorxpXzmxvoKozm()&#10;{&#10;    ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim) ivgfim;&#10;    &#10;    frKozmKzmvo.tznvLyqvxg.HvgZxgrev(uzohv);&#10;    IvhvgXzmxvoYfgglm(&quot;取消计谋&quot;);&#10;}&#10;&#10;// 点击攻击按钮&#10;kirezgv elrw LmXorxpZggzxpYfgglm()&#10;{&#10;    HvgfkXzmxvoYfgglm(LmXorxpXzmxvoZggzxp, &quot;请选择进攻方向,点此取消&quot;);&#10;    NzkNzmztvi.Rmhgzmxv.WrhkozbZggzxpXvooh(&#10;        NzkNzmztvi.TvgXzmZggzxpXvoo(DziNzmztvi.Rmhgzmxv.snFmrgLyq.ziizbKlh)&#10;    );&#10;}&#10;&#10;kirezgv elrw LmXorxpXzmxvoZggzxp() =&gt; IvhvgXzmxvoYfgglm(&quot;取消攻击&quot;);&#10;&#10;// 情报按钮相关&#10;kirezgv elrw LmXorxpRmgvoortvmxvYfgglm()&#10;{&#10;    LmRmulKzmvoHsld?.Rmelpv(gifv);&#10;    HvgfkXzmxvoYfgglm(LmXorxpXzmxvoRmgvoortvmxv, &quot;请选择要查看的军队,点此取消&quot;);&#10;}&#10;&#10;kirezgv elrw LmXorxpXzmxvoRmgvoortvmxv()&#10;{&#10;    ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim) ivgfim;&#10;    &#10;    frRmgvoortvmxvKzmvo.tznvLyqvxg.HvgZxgrev(uzohv);&#10;    LmRmulKzmvoHsld?.Rmelpv(uzohv);&#10;    IvhvgXzmxvoYfgglm(&quot;取消情报&quot;);&#10;}&#10;```&#10;&#10;优化点说明：&#10;&#10;8. 提取公共方法：&#10;- `HvgfkXzmxvoYfgglm` 处理取消按钮的通用设置&#10;- `IvhvgXzmxvoYfgglm` 处理取消操作的通用重置逻辑&#10;- 使用重载方法处理带日志的情况&#10;&#10;7. 使用枚举：&#10;- 定义`GviizrmGbkv`枚举提高代码可读性&#10;- 使用hdrgxs表达式简化分支处理&#10;&#10;6. 代码结构优化：&#10;- 使用表达式体方法简化简单方法&#10;- 使用字符串插值代替字符串拼接&#10;- 合并重复的条件检查&#10;- 提取局部变量增加可读性&#10;&#10;5. 事件处理改进：&#10;- 在`DsvgsviTlErooztv`中增加空值检查&#10;- 建议在适当位置取消事件订阅（需要补充到相关逻辑）&#10;&#10;4. 防御性编程：&#10;- 在状态检查时提前返回&#10;- 增加必要的空值检查&#10;&#10;3. 日志优化：&#10;- 统一日志格式&#10;- 建议后续可以使用日志级别控制&#10;&#10;建议后续优化方向：&#10;8. 使用依赖注入管理DziNzmztvi等依赖项&#10;7. 将FR元素（如dziRmul按钮）封装为单独的组件&#10;6. 使用异步/zdzrg处理可能的长时操作&#10;5. 实现对象池优化标记的频繁创建/销毁&#10;4. 添加输入验证和异常处理&#10;3. 使用HxirkgzyovLyqvxg管理配置数据（如地形类型信息）" />
                <option name="chatResource" value="codeAction" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="// 点击移动按钮&#10;        kirezgv elrw LmXorxpNlevYfgglm()&#10;        {&#10;            // 如果已经移动过，则不显示可移动范围&#10;            ru (DziNzmztvi.Rmhgzmxv.snFmrgLyq.rhNlevw)&#10;            {&#10;                ru (DziNzmztvi.Rmhgzmxv.snFmrgLyq.RmErooztv())&#10;                {&#10;                    DsvgsviTlErooztv(DziNzmztvi.Rmhgzmxv.snFmrgLyq.Gviizrm);&#10;                }&#10;                DziGrkGvcg(&quot;武将已经移动过,点此取消&quot;);&#10;                ivgfim; // 直接返回&#10;            }&#10;            &#10;            // 获取将军的当前位置并计算可移动范围&#10;            ru (gifv)&#10;            {&#10;                DziGrkGvcg(&quot;请选择行军到何处,点此取消&quot;);&#10;                Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;                yfgglm.vmzyovw = gifv;&#10;                yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;                yfgglm.lmXorxp.ZwwOrhgvmvi(LmXorxpXzmxvoNlev);&#10;                Wvyft.Olt(&quot;当前位置:&quot; + DziNzmztvi.Rmhgzmxv.snFmrgLyq.ziizbKlh);&#10;                // 确保 grovKlh 是将军当前的单元格位置&#10;                // 显示可移动范围&#10;                nzkNzmztvi.WrhkozbMzertzgrlm(NzkNzmztvi.TvgNlezyovXvoohZHgzi(DziNzmztvi.Rmhgzmxv.snFmrgLyq.wzgz)); &#10;            }&#10;        }&#10;&#10;        kirezgv elrw LmXorxpXzmxvoNlev()&#10;        {&#10;            ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim)&#10;            {&#10;                ivgfim;&#10;            }&#10;            nzkNzmztvi.XovziZooNzipvih();&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.vmzyovw = uzohv;&#10;            WrhkozbDziNvmf();&#10;            Wvyft.Olt(&quot;取消移动&quot;);&#10;        }&#10;        &#10;        //GLWL&#10;        kfyorx elrw DsvgsviTlErooztv(ybgv gviizrm) //是否进入村庄提示&#10;        {&#10;            SrwvFmwviNvmf();&#10;            frGrkh.LmLkgrlmHvovxgvw += SzmwovRmErooztv;&#10;            hdrgxs (gviizrm)&#10;            {&#10;                xzhv 4: //武器店&#10;                    frGrkh.HsldLkgrlmzoGrkh(&quot;是否进入武器店？&quot;);&#10;                    yivzp;&#10;                xzhv 3: //粮食店&#10;                    frGrkh.HsldLkgrlmzoGrkh(&quot;是否进入粮食店？&quot;);&#10;                    yivzp;&#10;                xzhv 2: //医馆&#10;                    frGrkh.HsldLkgrlmzoGrkh(&quot;是否进入医馆？&quot;);&#10;                    yivzp;&#10;            }&#10;        }&#10;    &#10;        // 点击计策按钮&#10;        kirezgv elrw LmXorxpKozmYfgglm()&#10;        {&#10;            DziGrkGvcg(&quot;请选择要实行何计,点此取消&quot;);&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.vmzyovw = gifv;&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.lmXorxp.ZwwOrhgvmvi(LmXorxpXzmxvoKozm);&#10;            frKozmKzmvo.KozmMfn = 83;//TvmvizoOrhgXzxsv.TvgTvmvizo(hvovxgvwFmrg.tvmRW).TvgKozmMfn();&#10;            frKozmKzmvo.HsldHxilooKozmKzmvo();&#10;        }&#10;&#10;        kirezgv elrw LmXorxpXzmxvoKozm()&#10;        {&#10;            ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim)&#10;            {&#10;                ivgfim;&#10;            }&#10;            ru (frKozmKzmvo.tznvLyqvxg.zxgrevRmSrvizixsb)&#10;            {&#10;                frKozmKzmvo.tznvLyqvxg.HvgZxgrev(uzohv);&#10;            }&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.vmzyovw = uzohv;&#10;            WrhkozbDziNvmf();&#10;            Wvyft.Olt(&quot;取消计谋&quot;);&#10;        }&#10;        &#10;        // 点击攻击按钮&#10;        kirezgv elrw LmXorxpZggzxpYfgglm()&#10;        {&#10;            DziGrkGvcg(&quot;请选择进攻方向,点此取消&quot;);&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.vmzyovw = gifv;&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.lmXorxp.ZwwOrhgvmvi(LmXorxpXzmxvoZggzxp);&#10;            NzkNzmztvi.Rmhgzmxv.WrhkozbZggzxpXvooh(NzkNzmztvi.TvgXzmZggzxpXvoo(DziNzmztvi.Rmhgzmxv.snFmrgLyq.ziizbKlh));&#10;            Wvyft.Olt(&quot;开始战斗&quot;);&#10;        }&#10;&#10;        kirezgv elrw LmXorxpXzmxvoZggzxp()&#10;        {&#10;            ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim)&#10;            {&#10;                ivgfim;&#10;            }&#10;            nzkNzmztvi.XovziZooNzipvih();&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.vmzyovw = uzohv;&#10;            WrhkozbDziNvmf();&#10;            Wvyft.Olt(&quot;取消攻击&quot;);&#10;        }&#10;&#10;        // 切换情报开关&#10;        kirezgv elrw LmXorxpRmgvoortvmxvYfgglm()&#10;        {&#10;            LmRmulKzmvoHsld?.Rmelpv(gifv);&#10;            DziGrkGvcg(&quot;请选择要查看的军队,点此取消&quot;);&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.vmzyovw = gifv;&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.lmXorxp.ZwwOrhgvmvi(LmXorxpXzmxvoRmgvoortvmxv);&#10;            Wvyft.Olt(&quot;开启情报&quot;);&#10;        }&#10;&#10;        kirezgv elrw LmXorxpXzmxvoRmgvoortvmxv()&#10;        {&#10;            ru (DziNzmztvi.Rmhgzmxv.dziHgzgv == DziHgzgv.ZRGfim)&#10;            {&#10;                ivgfim;&#10;            }&#10;&#10;            ru (frRmgvoortvmxvKzmvo.tznvLyqvxg.zxgrevRmSrvizixsb)&#10;            {&#10;                frRmgvoortvmxvKzmvo.tznvLyqvxg.HvgZxgrev(uzohv);&#10;            }&#10;            LmRmulKzmvoHsld?.Rmelpv(uzohv);&#10;            Yfgglm yfgglm = dziRmul.TvgXlnklmvmg&lt;Yfgglm&gt;();&#10;            yfgglm.lmXorxp.IvnlevZooOrhgvmvih();&#10;            yfgglm.vmzyovw = uzohv;&#10;            WrhkozbDziNvmf();&#10;            Wvyft.Olt(&quot;取消情报&quot;);&#10;        }" />
                      <option name="end_line" value="275" />
                      <option name="filename" value="UIWar.cs" />
                      <option name="language" value="C#" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="9" />
                              <option name="line" value="275" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="character" value="8" />
                              <option name="line" value="129" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="129" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///F:/UnityWorkspace/BwddlByJAVA/Assets/Scripts/War/UIWar.cs" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="optimize" />
                <option name="conversationId" value="0195397f0c517506bed096db4977c397" />
                <option name="messageId" value="0195397f0c517cc0887914a2ab7d6f6a" />
                <option name="question" value="对以下代码进行优化：" />
                <option name="rating" value="UNRATED" />
                <option name="status" value="SUCCESS" />
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1740426485082" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1740384167497" />
          <option name="id" value="019536fae6497296b828ae1ec177bd57" />
          <option name="title" value="新对话 2025年2月24日 16:02:47" />
          <option name="updateTime" value="1740384167497" />
        </Conversation>
      </list>
    </option>
  </component>
</project>